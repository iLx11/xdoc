## 任务挂起
```c
void vTaskSuspend(TaskHandle_t xTaskToSuspend);
```

## 任务恢复
```c
void vTaskResume(TaskHandle_t xTaskToResume);
```

## 中断服务中恢复任务
```c
void vTaskResumeFromISR(TaskHandle_t xTaskToResume);
```

## 全部挂起与恢复
```c
vTaskSuspendAll();
xTaskResumeAll(); 
```

## 获取任务当前状态。

#### eTaskGetState
函数	eTaskState eTaskGetState( TaskHandle_t xTask )

参数	xTask： 任务句柄

返回值：	以下值

```c
/* Task states returned by eTaskGetState. */
typedef enum
{
    eRunning = 0,     /* A task is querying the state of itself, so must be running. */
    eReady,           /* The task being queried is in a read or pending ready list. */
    eBlocked,         /* The task being queried is in the Blocked state. */
    eSuspended,       /* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */
    eDeleted,         /* The task being queried has been deleted, but its TCB has not yet been freed. */
    eInvalid          /* Used as an 'invalid state' value. */
} eTaskState;
```

## 获取节拍数

该函数返回的是一个全局的时钟节拍数，它表示自RTOS启动以来经过的完整时钟节拍数量。因此，无论在哪个任务或函数中调用 xTaskGetTickCount()，它都将返回相同的值，这个值代表了从RTOS启动到当前时间的总节拍数。

```c
TickType_t xTaskGetTickCount( void );

// 起始节拍
TickType_t t_start;
t_start = xTaskGetTickCount();
// 计数节拍，在一个 tick 后计数 (+1)
TickType_t t;
int flag = 0;

while (1) {
  t = xTaskGetTickCount();
  if (!flag && (t > t_start + 10)) {
    // 设置一个 flag 确保只执行一次
    flag = 1;  
  }
  // 在 21 个 tick 后
  if (t > t_start + 20)
}
```

## 空闲任务

空闲任务要么处于就绪态，要么处于运行态，永远不会阻塞

### 钩子函数

打开配置：
```c
#define configUSE_IDLE_HOOK			1
```

执行函数：

```c
void vApplicationIdleHook( void ){
    ///
}
```

 

## 是否抢占

不抢占的前提下，谁先执行谁就一直执行，除非放弃CPU资源

```c
/*调度算法策略*/
#define configIDLE_SHOULD_YIELD		1//空闲任务让位
#define configUSE_PREEMPTION		0//不执行强占
#define configUSE_TIME_SLICING      1//执行时间片轮转
```



# 使用实例

创建一个总任务，由总任务创建其他任务

```c
// led 任务
void led1_task(void *arg) {
    while (1) {
        HAL_GPIO_WritePin(GPIOF, GPIO_PIN_9, GPIO_PIN_SET);
        vTaskDelay(300);
        printf("in");
        HAL_GPIO_WritePin(GPIOF, GPIO_PIN_9, GPIO_PIN_RESET);
        vTaskDelay(300);
        printf("out");
    }
}

// 创建任务句柄
// 统一任务管理
static TaskHandle_t app_task_handle = NULL;
// 其他任务句柄
static TaskHandle_t led1_task_handle = NULL;

static void app_task_create(void) {
    BaseType_t x_return = pdPASS;
    // 创建其他任务
    x_return = xTaskCreate((TaskFunction_t )led1_task, /* 任务入口函数 */
                           (const char* )"LED1_Task",/* 任务名字 */
                           (uint16_t )512, /* 任务栈大小 */
                           (void* )NULL, /* 任务入口函数参数 */
                           (UBaseType_t )2, /* 任务的优先级 */
                           (TaskHandle_t* )&led1_task_handle);
    if(pdPASS == x_return) {
        printf("led task ok\r\n");
    }
	// 全部任务创建成功后删除总任务
    vTaskDelete(app_task_handle);
    taskEXIT_CRITICAL(); //退出临界区
}

int main(void) {
	BaseType_t x_return = pdPASS;
    x_return = xTaskCreate((TaskFunction_t) app_task_create, /* 任务入口函数 */
                          (const char *) "create_test",/* 任务名字 */
                          (uint16_t) 512, /* 任务栈大小 */
                          (void *) NULL,/* 任务入口函数参数 */
                          (UBaseType_t) 1, /* 任务的优先级 */
                          (TaskHandle_t *) &app_task_handle);/* 任务控制块指针 */
    if (pdPASS == x_return) {
        vTaskStartScheduler();
    } else {
        printf("test fail\r\n");
        return -1;
    }
}
```

## 
